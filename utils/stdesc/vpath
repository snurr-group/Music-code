#!/usr/bin/perl -w

# Operates on the ".cxns" file generated by the steepest descent code(mepdesc)
# to generate a rasmol files.  It tries to give you an interactive environment
# to facilitate going from one configuration to the next.
my $input_filename;
my @fileoffsets;
my $max_recs;
my $last_token;
my $curr_rec;
my @curr_list;
my $nheader_lines = 14;

# Check if the filename is a command line argument
if (@ARGV)
{
  setfilename($ARGV[0]);
}

# Set up the event loop
print("vpath> ");
$curr_rec = 1;
while(defined($line=<STDIN>))
{
  chop($line); #remove the newline character
  undef($value);
  ($keyword, $value) = (split(' ', $line, 2));
  if (!defined($keyword))
  {
    print("vpath> ");
    next;
  }
  $token = tokenizer($keyword);
  $last_token = $token;
  print "Incorrect command: $keyword\n" if ($token < 0);
  if ($token == 0)
  {
    setfilename($value);
  }
  elsif ($token == 1)
  {
    search($value);
  }
  elsif ($token == 2)
  {
    displaypath($value);
  }
  elsif ($token == 3)
  {
    showheader($value);
  }
  elsif ($token == 4)
  {
    displaypathlist($value);
  }
  elsif ($token == 5)
  {
    # Don't do anything token
  }
  print("vpath> ");
}

# Returns a number corresponding to the correct keyword
sub tokenizer($)
{
  my $keword = shift;
  if ($keyword eq "file")
  {
    return(0);
  }
  elsif ($keyword eq "s")
  {
    return(1);
  }
  elsif ($keyword eq "dp") # display the path
  {
    return(2);
  }
  elsif ($keyword eq "dh") # display the header
  {
    return(3);
  }
  elsif ($keyword eq "dl") # display the path list
  {
    return(4);
  }
  elsif ($keyword eq "n")
  {
    $curr_rec++;
    # make sure there are records to display
    if ($curr_rec > $max_recs)
    {
      print "No more records to display\n";
      return(5);
    }
    return($last_token);
  }
  return(-1);
}

# Generates a list format from a list containing a series of numbers
sub genlistfmt()
{
  
}

# Gets the header fields of the record number passed to it
sub getrec($\@)
{
  my $recno= shift;
  my $refrec= shift;
  my ($currpos, $i, $inputline);
  
  $currpos = $fileoffsets[$recno];
  seek(INPUTFILE, $currpos, 0);
  for($i=0; $i<$nheader_lines; $i++)
  {
    $inputline = <INPUTFILE>;
    chop($inputline);
    push(@{$refrec}, $inputline);
  }
}


# Gets a perlish expression from the user and do queries on it
sub search($)
{
  my $expr = shift;
  my ($i, $f, $result, @searchlist);
  my ($e1ts, $e2ts, $npts1, $npts2, $st1, $stTS, $st2);
  my @rec;
  
  if (!(defined($expr)))
  {
    print 'search fields: $e1ts, $e2ts, $npts1, $npts2, $st1, $stTS, $st2',"\n";
    return;
  }
  
  # write a diagnostic message
  print "Searching through $max_recs records for $expr\n";
  
  # start the search
  for($i=0; $i<$max_recs; $i++)
  {
    # Get the record header
    undef(@rec);
    getrec($i+1, @rec);
    
    # Get the values on which we can search
    foreach $f (@rec)
    {
      if ($f =~ /_1_TS_ENERGY/oi)
      {
	$e1ts = (split(":", $f))[1];
      }
      elsif ($f =~ /_2_TS_ENERGY/oi)
      {
	$e2ts = (split(":", $f))[1];
      }
      elsif ($f =~ /_NPTS1/oi)
      {
	$npts1 = (split(":", $f))[1];
      }
      elsif ($f =~ /_NPTS2/oi)
      {
	$npts2 = (split(":", $f))[1];
      }
      elsif ($f =~ /_SITE_TYPES\(1\)/oi)
      {
	$st1 = (split(":", $f))[1];
      }
      elsif ($f =~ /_SITE_TYPES\(TS\)/oi)
      {
	$stTS = (split(":", $f))[1];
      }
      elsif ($f =~ /_SITE_TYPES\(2\)/oi)
      {
	$st2 = (split(":", $f))[1];
      }
    }
    
    # eval the expression
    $result = eval($expr);
    if ($@)
    {
      print "Cannot evaluate search\n";
    }
    elsif ($result)
    {
      push(@searchlist, ($i+1));
    }
  }
  print "@searchlist\n";
}


# Gets the points for the record number "$recno"
sub getpts($\@\@\@)
{
  my $recno = shift;
  my $refmin1 = shift;
  my $refmin2 = shift;
  my $refts   = shift;
  my ($npts1, $npts2, $inputline, $i);
  
  # Set the file position to the right place
  $currpos = $fileoffsets[$recno];
  seek(INPUTFILE, $currpos, 0);
  
  # Get the no. of points from min1 to TS and min2 to TS
  for($i=0; $i<$nheader_lines; $i++)
  {
    $inputline = <INPUTFILE>;
    chop($inputline);
    if ($inputline =~ /_NPTS1/oi)
    {
      $npts1 = (split(/:/,$inputline))[1];
    }
    if ($inputline =~ /_NPTS2/oi)
    {
      $npts2 = (split(/:/,$inputline))[1];
    }
  }
  print "No. of points: $npts1, $npts2\n";
  
  # Get the points from min1 to TS
  # Read the next line and parse it to get the x, y, z positions
  undef(@{$refmin1});
  $inputline = <INPUTFILE>;
  chop($inputline);
  ($x, $y, $z) = split(' ', (split(/:/, $inputline))[1]);
  $$refmin1[0][0] = $x;
  $$refmin1[0][1] = $y;
  $$refmin1[0][2] = $z;
  for($i=1;$i<$npts1;$i++)
  {
    $inputline = <INPUTFILE>;
    chop($inputline);
    ($x, $y, $z) = split(' ', $inputline);
    $$refmin1[$i][0] = $x;	
    $$refmin1[$i][1] = $y;	
    $$refmin1[$i][2] = $z;	
  }
  
  # Get the transition state
  undef(@{$refts});
  $inputline = <INPUTFILE>;
  chop($inputline);
  ($x, $y, $z) = split(' ', (split(/:/, $inputline))[1]);
  $$refts[0] = $x;
  $$refts[1] = $y;
  $$refts[2] = $z;
  
  # Get the points from TS to min2
  undef(@{$refmin2});
  for($i=0;$i<$npts2-1;$i++)
  {
    $inputline = <INPUTFILE>;
    chop($inputline);
    ($x, $y, $z) = split(' ', $inputline);
    $$refmin2[$i][0] = $x;	
    $$refmin2[$i][1] = $y;	
    $$refmin2[$i][2] = $z;	
  }
  $inputline = <INPUTFILE>;
  chop($inputline);
  ($x, $y, $z) = split(' ', (split(/:/, $inputline))[1]);
  $$refmin2[$i][0] = $x;
  $$refmin2[$i][1] = $y;
  $$refmin2[$i][2] = $z;
}


# Gets called when the "file" keyword is entered
sub setfilename($)
{
  my $filename = shift;
  my ($input_filename, $inputline, $currpos, $recordno);

  $input_filename = $filename;
  open(INPUTFILE, $input_filename)
    || die "Could not open file $filename: $!\n";
  $recordno = 0;
  undef(@fileoffsets);
  while(defined($inputline=<INPUTFILE>))
  {
    if ($inputline =~ /-------------------/o)
    {
      $recordno++;
      $currpos = tell(INPUTFILE);
      $fileoffsets[$recordno] = $currpos;
    }
  }
  $max_recs = $recordno;
  print"No. of records read $max_recs\n";
}


# Show one steepest descent path
sub displaypath($)
{
  my $recno = shift;
  my ($npts1, $npts2, $totpts);
  
  # if the record number is not defined then set it from the
  # current record no.
  if (!(defined($recno)))
  {
    $recno = $curr_rec;
  }
  
  getpts($recno, @min1ts, @min2ts, @ts);
  $npts1 = @min1ts;
  $npts2 = @min2ts;
  $totpts = $npts1 + $npts2 + 1;
  $outfilename = $input_filename.".".$recno.".xyz";
  open(OUTFILE, ">$outfilename");
  print OUTFILE "0\n\n";
  print OUTFILE "He  @{$min1ts[0]}\n";
  for($i=1; $i<$npts1; $i++)
  {
    print OUTFILE "Ne  @{$min1ts[$i]}\n";
  }
  print OUTFILE "Ar  @ts\n";
  for($i=0; $i<$npts2-1; $i++)
  {
    print OUTFILE "Ne  @{$min2ts[$i]}\n";
  }
  print OUTFILE "He  @{$min2ts[$i]}\n";  
  close(OUTFILE);
  system("/home/amit/bin/displayzeo $outfilename");
  $curr_rec = $recno;
}

# Takes an expression describing the range of paths and returns
# an array containing the individual record nos. 
sub parselist($\@)
{
  my $list = shift;
  my $reflist=shift;
  my ($i, $f, $num1, $num2, @commas);
  
  #split on the commas first
  @commas = split(/,/,$list);
  foreach $f (@commas)
  {
    if ($f =~ /-/)
    {
      ($num1, $num2) = split(/-/, $f, 2);
      for($i=$num1; $i<=$num2; $i++)
      {
	push(@{$reflist}, $i);
      }
    }
    else
    {
      push(@{$reflist}, $f);
    }
  }
}

# Display the record "$recno"
sub showheader($)
{
  my $recno = shift;
  my (@recs, @header);
  my ($f);
  
  # if the record number is not defined then increment the
  # recordno from $last_value
  if (!(defined($recno)))
  {
    $recno = $curr_rec;
  }
  else
  {
    parselist($recno, @recs);
  }
  
  foreach $f (@recs)
  {
    undef(@header);
    getrec($f, @header);
    foreach $f (@header)
    {
      print "$f\n";
    }
    print "===========================================\n";
    $curr_rec = $f;
  }
}

# Show all the steepest descent paths
sub displaypathlist($)
{
  my $params = shift;
  my ($i, $filename, $npts1, $npts2);
  my (@recno, @listelems, @min1ts, @min2ts, @ts);
  
  $params =~ /^\s*([,\s\-\d]*)\s+(.*)/oi;
  $list = $1;
  $filename = $2;
  print "list: $list\n";
  print "file: $filename\n";
  
  parselist($list, @listelems);
  print"showing paths: @listelems\n";
  open(OUTFILE, ">$filename");
  print OUTFILE "0\n\n";
  foreach $recno (@listelems)
  {
    undef(@min1ts);
    undef(@min2ts);
    undef(@ts);
    getpts($recno, @min1ts, @min2ts, @ts);
    $npts1 = @min1ts;
    $npts2 = @min2ts;
    print OUTFILE "He  @{$min1ts[0]}\n";
    for($i=1; $i<$npts1; $i++)
    {
      print OUTFILE "Ne  @{$min1ts[$i]}\n";
    }
    print OUTFILE "Ar  @ts\n";
    for($i=0; $i<$npts2-1; $i++)
    {
      print OUTFILE "Ne  @{$min2ts[$i]}\n";
    }
    print OUTFILE "He  @{$min2ts[$i]}\n";  
  }
  close(OUTFILE);
  system("~/bin/displayzeo $filename");
}






